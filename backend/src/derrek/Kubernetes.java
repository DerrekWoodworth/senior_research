package derrek;

import com.google.common.io.ByteStreams;
import io.kubernetes.client.Copy;
import io.kubernetes.client.Exec;
import io.kubernetes.client.custom.IntOrString;
import io.kubernetes.client.custom.Quantity;
import io.kubernetes.client.openapi.ApiClient;
import io.kubernetes.client.openapi.ApiException;
import io.kubernetes.client.openapi.Configuration;
import io.kubernetes.client.openapi.apis.AppsV1Api;
import io.kubernetes.client.openapi.apis.CoreV1Api;
import io.kubernetes.client.openapi.models.*;
import io.kubernetes.client.util.Config;
import io.kubernetes.client.util.ClientBuilder;

import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.lang.Process;

/*
  Kubernetes Java client was autogenerated. So the development workflow is to mirror the yaml declerations through the
  fluent api. It is a terrible terrible hassle to write in clojure. Since clojure is built for the JVM we can have a ploygot
  project and leverage java where it is most effective.
  This class handles all interaction between the Kubernetes cluster and Jace
 */
public class Kubernetes {
  private static CoreV1Api coreV1Api;
  private static AppsV1Api appsV1Api;
  private static Copy copy;

  public static void setApis() throws IOException, ApiException {
    Configuration.setDefaultApiClient(ClientBuilder.cluster().build());
    coreV1Api = new CoreV1Api();
    appsV1Api = new AppsV1Api();
    copy = new Copy();
  }
  public static V1PersistentVolumeClaim createPVCSpec(String name, String size) {
    return new V1PersistentVolumeClaimBuilder()
      .withNewMetadata()
      .withName(name)
      .endMetadata()
      .withNewSpec()
      .withNewResources()
      .withRequests(Map.of("storage", new Quantity(size)))
      .withLimits(Map.of("storage", new Quantity(size)))
      .endResources()
      .addNewAccessMode("ReadOnlyMany")
      .endSpec()
      .build();
  }

  public static void copyFileToPVC(String filepath, String podname) throws IOException {
    String[] cmd = {
	    "/bin/sh",
	    "-c",
	    "cat /tmp/" + filepath + " | kubectl exec " + podname + " --stdin -- tar -xvf - -C /startup"
    };

    Process p = Runtime.getRuntime().exec(cmd);

    BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
    BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));

    String s = null;
    while((s = stdInput.readLine()) != null) {
       System.out.println(s);
    }
    System.out.println("ERROR");
    while((s = stdError.readLine()) != null) {
       System.out.println(s);
    }
  }

  public static V1Pod initPVCPod(String pvcName, String podname) {
    return new V1PodBuilder()
      .withNewMetadata()
      .withName(podname)
      .endMetadata()
      .withNewSpec()
      .addNewVolume()
      .withName("startup")
      .withNewPersistentVolumeClaim()
      .withClaimName(pvcName)
      .endPersistentVolumeClaim()
      .endVolume()
      .addNewContainer()
      .withName("container")
      .withImage("ubuntu")
      .addNewVolumeMount()
      .withName("startup")
      .withMountPath("/startup")
      .endVolumeMount()
      .withCommand(List.of(
        "/bin/bash",
        "-c",
        "sleep 3600"
      ))
      .endContainer()
      .endSpec()
      .build();
  }

  public static V1Pod createInitPod(V1Pod pod) {
    V1Pod pod = null;
    try {
      pod = coreV1Api.createNamespacedPod("default", pod, null, null, null);
    } catch(ApiException e) {
      System.out.println(e.getResponseBody())
    }
    return pod;
  }

  /*
    Create a deployment obj for a container from the string pvc
   */
  public static V1Deployment createContainerSpec(String scenario, String student, String pvc) {
    return new V1DeploymentBuilder()
      .withNewMetadata()
      .withName(scenario + "-" + student + "-deployment")
      .endMetadata()
      .withNewSpec()
      .withSelector(
        new V1LabelSelectorBuilder()
        .addToMatchLabels("scenario", scenario)
        .addToMatchLabels("student", student)
        .build()
      )
      .withNewTemplate()
      .withNewMetadata()
      .addToLabels("scenario", scenario)
      .addToLabels("student", student)
      .endMetadata()
      .withNewSpec()
      .withVolumes(List.of(
        new V1VolumeBuilder()
        .withName("startup-volume")
        .withPersistentVolumeClaim(new V1PersistentVolumeClaimVolumeSourceBuilder()
        .withClaimName(pvc)
        .withReadOnly(true).build()).build()))
      .addNewContainer()
      .withName("scenario-to-container")
      .withImage("ubuntu")
      .addNewCommand("/startup/start.sh")
      .withVolumeMounts(new V1VolumeMountBuilder()
      .withMountPath("/startup")
      .withName("startup-volume")
      .withReadOnly(true).build())
      .addToPorts(new V1ContainerPortBuilder()
        // Port 80 on the container is to be exposed
        .withContainerPort(80)
        .build())
      .endContainer()
      .endSpec()
      .endTemplate()
      .endSpec()
      .build();
  }

  public static V1Service createServiceSpec(String scenario, String student) {
    return new V1ServiceBuilder()
      .withNewMetadata()
      .withName("Scenario-service-for-container")
      .endMetadata()
      .withNewSpec()
      .withSelector(Map.of("scenario", scenario, "student", student))
      .addToPorts(new V1ServicePortBuilder()
        .withProtocol("TCP")
        .withPort(80)
        .withTargetPort(new IntOrString(80))
      .build())
      .withNewType("NodePort")
      .endSpec()
      .build();
  }

  public static V1Service createServiceInCluster(V1Service service) {
    V1Service service = null;
    try {
      service = coreV1Api.createNamespacedService("default", service, null, null, null);
    } catch(ApiException e) {
      System.out.println(e.getResponseBody())
    }
    return service;
  }

  public static V1PersistentVolumeClaim createPVCInCluster(V1PersistentVolumeClaim claim) {
    V1PersistentVolumeClaim pvc = null;
    try {
      pvc =  coreV1Api.createNamespacedPersistentVolumeClaim("default", claim, null,null,null);
    } catch(ApiException e) {
      System.out.println(e.getResponseBody())
    }
    return pvc;
  }

  public static V1Deployment createContainer(V1Deployment deployment) {
    V1Deployment deployment = null;
    try {
      deployment = appsV1Api.createNamespacedDeployment("default", deployment, null, null, null);
    } catch(ApiException e) {
      System.out.println(e.getResponseBody())
    }
    return deployment;
  }
}
